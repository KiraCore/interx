// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cosmos/tx/v1beta1/tx.proto

package tx

import (
	fmt "fmt"
	types "github.com/cosmos/cosmos-sdk/crypto/types"
	types1 "github.com/cosmos/cosmos-sdk/types"
	signing "github.com/cosmos/cosmos-sdk/types/tx/signing"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	anypb "google.golang.org/protobuf/types/known/anypb"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Tx is the standard type used for broadcasting transactions.
type Tx struct {
	// body is the processable content of the transaction
	Body *TxBody `protobuf:"bytes,1,opt,name=body,proto3" json:"body,omitempty"`
	// auth_info is the authorization related content of the transaction,
	// specifically signers, signer modes and fee
	AuthInfo *AuthInfo `protobuf:"bytes,2,opt,name=auth_info,json=authInfo,proto3" json:"auth_info,omitempty"`
	// signatures is a list of signatures that matches the length and order of
	// AuthInfo's signer_infos to allow connecting signature meta information like
	// public key and signing mode by position.
	Signatures           [][]byte `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Tx) Reset()         { *m = Tx{} }
func (m *Tx) String() string { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()    {}
func (*Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{0}
}

func (m *Tx) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Tx.Unmarshal(m, b)
}
func (m *Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Tx.Marshal(b, m, deterministic)
}
func (m *Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tx.Merge(m, src)
}
func (m *Tx) XXX_Size() int {
	return xxx_messageInfo_Tx.Size(m)
}
func (m *Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Tx proto.InternalMessageInfo

func (m *Tx) GetBody() *TxBody {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Tx) GetAuthInfo() *AuthInfo {
	if m != nil {
		return m.AuthInfo
	}
	return nil
}

func (m *Tx) GetSignatures() [][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// TxRaw is a variant of Tx that pins the signer's exact binary representation
// of body and auth_info. This is used for signing, broadcasting and
// verification. The binary `serialize(tx: TxRaw)` is stored in Tendermint and
// the hash `sha256(serialize(tx: TxRaw))` becomes the "txhash", commonly used
// as the transaction ID.
type TxRaw struct {
	// body_bytes is a protobuf serialization of a TxBody that matches the
	// representation in SignDoc.
	BodyBytes []byte `protobuf:"bytes,1,opt,name=body_bytes,json=bodyBytes,proto3" json:"body_bytes,omitempty"`
	// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
	// representation in SignDoc.
	AuthInfoBytes []byte `protobuf:"bytes,2,opt,name=auth_info_bytes,json=authInfoBytes,proto3" json:"auth_info_bytes,omitempty"`
	// signatures is a list of signatures that matches the length and order of
	// AuthInfo's signer_infos to allow connecting signature meta information like
	// public key and signing mode by position.
	Signatures           [][]byte `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxRaw) Reset()         { *m = TxRaw{} }
func (m *TxRaw) String() string { return proto.CompactTextString(m) }
func (*TxRaw) ProtoMessage()    {}
func (*TxRaw) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{1}
}

func (m *TxRaw) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TxRaw.Unmarshal(m, b)
}
func (m *TxRaw) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TxRaw.Marshal(b, m, deterministic)
}
func (m *TxRaw) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRaw.Merge(m, src)
}
func (m *TxRaw) XXX_Size() int {
	return xxx_messageInfo_TxRaw.Size(m)
}
func (m *TxRaw) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRaw.DiscardUnknown(m)
}

var xxx_messageInfo_TxRaw proto.InternalMessageInfo

func (m *TxRaw) GetBodyBytes() []byte {
	if m != nil {
		return m.BodyBytes
	}
	return nil
}

func (m *TxRaw) GetAuthInfoBytes() []byte {
	if m != nil {
		return m.AuthInfoBytes
	}
	return nil
}

func (m *TxRaw) GetSignatures() [][]byte {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// SignDoc is the type used for generating sign bytes for SIGN_MODE_DIRECT.
type SignDoc struct {
	// body_bytes is protobuf serialization of a TxBody that matches the
	// representation in TxRaw.
	BodyBytes []byte `protobuf:"bytes,1,opt,name=body_bytes,json=bodyBytes,proto3" json:"body_bytes,omitempty"`
	// auth_info_bytes is a protobuf serialization of an AuthInfo that matches the
	// representation in TxRaw.
	AuthInfoBytes []byte `protobuf:"bytes,2,opt,name=auth_info_bytes,json=authInfoBytes,proto3" json:"auth_info_bytes,omitempty"`
	// chain_id is the unique identifier of the chain this transaction targets.
	// It prevents signed transactions from being used on another chain by an
	// attacker
	ChainId string `protobuf:"bytes,3,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// account_number is the account number of the account in state
	AccountNumber        uint64   `protobuf:"varint,4,opt,name=account_number,json=accountNumber,proto3" json:"account_number,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignDoc) Reset()         { *m = SignDoc{} }
func (m *SignDoc) String() string { return proto.CompactTextString(m) }
func (*SignDoc) ProtoMessage()    {}
func (*SignDoc) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{2}
}

func (m *SignDoc) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignDoc.Unmarshal(m, b)
}
func (m *SignDoc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignDoc.Marshal(b, m, deterministic)
}
func (m *SignDoc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignDoc.Merge(m, src)
}
func (m *SignDoc) XXX_Size() int {
	return xxx_messageInfo_SignDoc.Size(m)
}
func (m *SignDoc) XXX_DiscardUnknown() {
	xxx_messageInfo_SignDoc.DiscardUnknown(m)
}

var xxx_messageInfo_SignDoc proto.InternalMessageInfo

func (m *SignDoc) GetBodyBytes() []byte {
	if m != nil {
		return m.BodyBytes
	}
	return nil
}

func (m *SignDoc) GetAuthInfoBytes() []byte {
	if m != nil {
		return m.AuthInfoBytes
	}
	return nil
}

func (m *SignDoc) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *SignDoc) GetAccountNumber() uint64 {
	if m != nil {
		return m.AccountNumber
	}
	return 0
}

// TxBody is the body of a transaction that all signers sign over.
type TxBody struct {
	// messages is a list of messages to be executed. The required signers of
	// those messages define the number and order of elements in AuthInfo's
	// signer_infos and Tx's signatures. Each required signer address is added to
	// the list only the first time it occurs.
	// By convention, the first required signer (usually from the first message)
	// is referred to as the primary signer and pays the fee for the whole
	// transaction.
	Messages []*anypb.Any `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
	// memo is any arbitrary note/comment to be added to the transaction.
	// WARNING: in clients, any publicly exposed text should not be called memo,
	// but should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122).
	Memo string `protobuf:"bytes,2,opt,name=memo,proto3" json:"memo,omitempty"`
	// timeout is the block height after which this transaction will not
	// be processed by the chain
	TimeoutHeight uint64 `protobuf:"varint,3,opt,name=timeout_height,json=timeoutHeight,proto3" json:"timeout_height,omitempty"`
	// extension_options are arbitrary options that can be added by chains
	// when the default options are not sufficient. If any of these are present
	// and can't be handled, the transaction will be rejected
	ExtensionOptions []*anypb.Any `protobuf:"bytes,1023,rep,name=extension_options,json=extensionOptions,proto3" json:"extension_options,omitempty"`
	// extension_options are arbitrary options that can be added by chains
	// when the default options are not sufficient. If any of these are present
	// and can't be handled, they will be ignored
	NonCriticalExtensionOptions []*anypb.Any `protobuf:"bytes,2047,rep,name=non_critical_extension_options,json=nonCriticalExtensionOptions,proto3" json:"non_critical_extension_options,omitempty"`
	XXX_NoUnkeyedLiteral        struct{}     `json:"-"`
	XXX_unrecognized            []byte       `json:"-"`
	XXX_sizecache               int32        `json:"-"`
}

func (m *TxBody) Reset()         { *m = TxBody{} }
func (m *TxBody) String() string { return proto.CompactTextString(m) }
func (*TxBody) ProtoMessage()    {}
func (*TxBody) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{3}
}

func (m *TxBody) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TxBody.Unmarshal(m, b)
}
func (m *TxBody) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TxBody.Marshal(b, m, deterministic)
}
func (m *TxBody) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxBody.Merge(m, src)
}
func (m *TxBody) XXX_Size() int {
	return xxx_messageInfo_TxBody.Size(m)
}
func (m *TxBody) XXX_DiscardUnknown() {
	xxx_messageInfo_TxBody.DiscardUnknown(m)
}

var xxx_messageInfo_TxBody proto.InternalMessageInfo

func (m *TxBody) GetMessages() []*anypb.Any {
	if m != nil {
		return m.Messages
	}
	return nil
}

func (m *TxBody) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *TxBody) GetTimeoutHeight() uint64 {
	if m != nil {
		return m.TimeoutHeight
	}
	return 0
}

func (m *TxBody) GetExtensionOptions() []*anypb.Any {
	if m != nil {
		return m.ExtensionOptions
	}
	return nil
}

func (m *TxBody) GetNonCriticalExtensionOptions() []*anypb.Any {
	if m != nil {
		return m.NonCriticalExtensionOptions
	}
	return nil
}

// AuthInfo describes the fee and signer modes that are used to sign a
// transaction.
type AuthInfo struct {
	// signer_infos defines the signing modes for the required signers. The number
	// and order of elements must match the required signers from TxBody's
	// messages. The first element is the primary signer and the one which pays
	// the fee.
	SignerInfos []*SignerInfo `protobuf:"bytes,1,rep,name=signer_infos,json=signerInfos,proto3" json:"signer_infos,omitempty"`
	// Fee is the fee and gas limit for the transaction. The first signer is the
	// primary signer and the one which pays the fee. The fee can be calculated
	// based on the cost of evaluating the body and doing signature verification
	// of the signers. This can be estimated via simulation.
	Fee                  *Fee     `protobuf:"bytes,2,opt,name=fee,proto3" json:"fee,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthInfo) Reset()         { *m = AuthInfo{} }
func (m *AuthInfo) String() string { return proto.CompactTextString(m) }
func (*AuthInfo) ProtoMessage()    {}
func (*AuthInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{4}
}

func (m *AuthInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthInfo.Unmarshal(m, b)
}
func (m *AuthInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthInfo.Marshal(b, m, deterministic)
}
func (m *AuthInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthInfo.Merge(m, src)
}
func (m *AuthInfo) XXX_Size() int {
	return xxx_messageInfo_AuthInfo.Size(m)
}
func (m *AuthInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthInfo proto.InternalMessageInfo

func (m *AuthInfo) GetSignerInfos() []*SignerInfo {
	if m != nil {
		return m.SignerInfos
	}
	return nil
}

func (m *AuthInfo) GetFee() *Fee {
	if m != nil {
		return m.Fee
	}
	return nil
}

// SignerInfo describes the public key and signing mode of a single top-level
// signer.
type SignerInfo struct {
	// public_key is the public key of the signer. It is optional for accounts
	// that already exist in state. If unset, the verifier can use the required \
	// signer address for this position and lookup the public key.
	PublicKey *anypb.Any `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// mode_info describes the signing mode of the signer and is a nested
	// structure to support nested multisig pubkey's
	ModeInfo *ModeInfo `protobuf:"bytes,2,opt,name=mode_info,json=modeInfo,proto3" json:"mode_info,omitempty"`
	// sequence is the sequence of the account, which describes the
	// number of committed transactions signed by a given address. It is used to
	// prevent replay attacks.
	Sequence             uint64   `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SignerInfo) Reset()         { *m = SignerInfo{} }
func (m *SignerInfo) String() string { return proto.CompactTextString(m) }
func (*SignerInfo) ProtoMessage()    {}
func (*SignerInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{5}
}

func (m *SignerInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignerInfo.Unmarshal(m, b)
}
func (m *SignerInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignerInfo.Marshal(b, m, deterministic)
}
func (m *SignerInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignerInfo.Merge(m, src)
}
func (m *SignerInfo) XXX_Size() int {
	return xxx_messageInfo_SignerInfo.Size(m)
}
func (m *SignerInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SignerInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SignerInfo proto.InternalMessageInfo

func (m *SignerInfo) GetPublicKey() *anypb.Any {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *SignerInfo) GetModeInfo() *ModeInfo {
	if m != nil {
		return m.ModeInfo
	}
	return nil
}

func (m *SignerInfo) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

// ModeInfo describes the signing mode of a single or nested multisig signer.
type ModeInfo struct {
	// sum is the oneof that specifies whether this represents a single or nested
	// multisig signer
	//
	// Types that are valid to be assigned to Sum:
	//	*ModeInfo_Single_
	//	*ModeInfo_Multi_
	Sum                  isModeInfo_Sum `protobuf_oneof:"sum"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ModeInfo) Reset()         { *m = ModeInfo{} }
func (m *ModeInfo) String() string { return proto.CompactTextString(m) }
func (*ModeInfo) ProtoMessage()    {}
func (*ModeInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{6}
}

func (m *ModeInfo) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModeInfo.Unmarshal(m, b)
}
func (m *ModeInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModeInfo.Marshal(b, m, deterministic)
}
func (m *ModeInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModeInfo.Merge(m, src)
}
func (m *ModeInfo) XXX_Size() int {
	return xxx_messageInfo_ModeInfo.Size(m)
}
func (m *ModeInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ModeInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ModeInfo proto.InternalMessageInfo

type isModeInfo_Sum interface {
	isModeInfo_Sum()
}

type ModeInfo_Single_ struct {
	Single *ModeInfo_Single `protobuf:"bytes,1,opt,name=single,proto3,oneof"`
}

type ModeInfo_Multi_ struct {
	Multi *ModeInfo_Multi `protobuf:"bytes,2,opt,name=multi,proto3,oneof"`
}

func (*ModeInfo_Single_) isModeInfo_Sum() {}

func (*ModeInfo_Multi_) isModeInfo_Sum() {}

func (m *ModeInfo) GetSum() isModeInfo_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *ModeInfo) GetSingle() *ModeInfo_Single {
	if x, ok := m.GetSum().(*ModeInfo_Single_); ok {
		return x.Single
	}
	return nil
}

func (m *ModeInfo) GetMulti() *ModeInfo_Multi {
	if x, ok := m.GetSum().(*ModeInfo_Multi_); ok {
		return x.Multi
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ModeInfo) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ModeInfo_Single_)(nil),
		(*ModeInfo_Multi_)(nil),
	}
}

// Single is the mode info for a single signer. It is structured as a message
// to allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the
// future
type ModeInfo_Single struct {
	// mode is the signing mode of the single signer
	Mode                 signing.SignMode `protobuf:"varint,1,opt,name=mode,proto3,enum=cosmos.tx.signing.v1beta1.SignMode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ModeInfo_Single) Reset()         { *m = ModeInfo_Single{} }
func (m *ModeInfo_Single) String() string { return proto.CompactTextString(m) }
func (*ModeInfo_Single) ProtoMessage()    {}
func (*ModeInfo_Single) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{6, 0}
}

func (m *ModeInfo_Single) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModeInfo_Single.Unmarshal(m, b)
}
func (m *ModeInfo_Single) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModeInfo_Single.Marshal(b, m, deterministic)
}
func (m *ModeInfo_Single) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModeInfo_Single.Merge(m, src)
}
func (m *ModeInfo_Single) XXX_Size() int {
	return xxx_messageInfo_ModeInfo_Single.Size(m)
}
func (m *ModeInfo_Single) XXX_DiscardUnknown() {
	xxx_messageInfo_ModeInfo_Single.DiscardUnknown(m)
}

var xxx_messageInfo_ModeInfo_Single proto.InternalMessageInfo

func (m *ModeInfo_Single) GetMode() signing.SignMode {
	if m != nil {
		return m.Mode
	}
	return signing.SignMode_SIGN_MODE_UNSPECIFIED
}

// Multi is the mode info for a multisig public key
type ModeInfo_Multi struct {
	// bitarray specifies which keys within the multisig are signing
	Bitarray *types.CompactBitArray `protobuf:"bytes,1,opt,name=bitarray,proto3" json:"bitarray,omitempty"`
	// mode_infos is the corresponding modes of the signers of the multisig
	// which could include nested multisig public keys
	ModeInfos            []*ModeInfo `protobuf:"bytes,2,rep,name=mode_infos,json=modeInfos,proto3" json:"mode_infos,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ModeInfo_Multi) Reset()         { *m = ModeInfo_Multi{} }
func (m *ModeInfo_Multi) String() string { return proto.CompactTextString(m) }
func (*ModeInfo_Multi) ProtoMessage()    {}
func (*ModeInfo_Multi) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{6, 1}
}

func (m *ModeInfo_Multi) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModeInfo_Multi.Unmarshal(m, b)
}
func (m *ModeInfo_Multi) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModeInfo_Multi.Marshal(b, m, deterministic)
}
func (m *ModeInfo_Multi) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModeInfo_Multi.Merge(m, src)
}
func (m *ModeInfo_Multi) XXX_Size() int {
	return xxx_messageInfo_ModeInfo_Multi.Size(m)
}
func (m *ModeInfo_Multi) XXX_DiscardUnknown() {
	xxx_messageInfo_ModeInfo_Multi.DiscardUnknown(m)
}

var xxx_messageInfo_ModeInfo_Multi proto.InternalMessageInfo

func (m *ModeInfo_Multi) GetBitarray() *types.CompactBitArray {
	if m != nil {
		return m.Bitarray
	}
	return nil
}

func (m *ModeInfo_Multi) GetModeInfos() []*ModeInfo {
	if m != nil {
		return m.ModeInfos
	}
	return nil
}

// Fee includes the amount of coins paid in fees and the maximum
// gas to be used by the transaction. The ratio yields an effective "gasprice",
// which must be above some miminum to be accepted into the mempool.
type Fee struct {
	// amount is the amount of coins to be paid as a fee
	Amount []*types1.Coin `protobuf:"bytes,1,rep,name=amount,proto3" json:"amount,omitempty"`
	// gas_limit is the maximum gas that can be used in transaction processing
	// before an out of gas error occurs
	GasLimit uint64 `protobuf:"varint,2,opt,name=gas_limit,json=gasLimit,proto3" json:"gas_limit,omitempty"`
	// if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.
	// the payer must be a tx signer (and thus have signed this field in AuthInfo).
	// setting this field does *not* change the ordering of required signers for the transaction.
	Payer string `protobuf:"bytes,3,opt,name=payer,proto3" json:"payer,omitempty"`
	// if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used
	// to pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does
	// not support fee grants, this will fail
	Granter              string   `protobuf:"bytes,4,opt,name=granter,proto3" json:"granter,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Fee) Reset()         { *m = Fee{} }
func (m *Fee) String() string { return proto.CompactTextString(m) }
func (*Fee) ProtoMessage()    {}
func (*Fee) Descriptor() ([]byte, []int) {
	return fileDescriptor_96d1575ffde80842, []int{7}
}

func (m *Fee) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Fee.Unmarshal(m, b)
}
func (m *Fee) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Fee.Marshal(b, m, deterministic)
}
func (m *Fee) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fee.Merge(m, src)
}
func (m *Fee) XXX_Size() int {
	return xxx_messageInfo_Fee.Size(m)
}
func (m *Fee) XXX_DiscardUnknown() {
	xxx_messageInfo_Fee.DiscardUnknown(m)
}

var xxx_messageInfo_Fee proto.InternalMessageInfo

func (m *Fee) GetAmount() []*types1.Coin {
	if m != nil {
		return m.Amount
	}
	return nil
}

func (m *Fee) GetGasLimit() uint64 {
	if m != nil {
		return m.GasLimit
	}
	return 0
}

func (m *Fee) GetPayer() string {
	if m != nil {
		return m.Payer
	}
	return ""
}

func (m *Fee) GetGranter() string {
	if m != nil {
		return m.Granter
	}
	return ""
}

func init() {
	proto.RegisterType((*Tx)(nil), "cosmos.tx.v1beta1.Tx")
	proto.RegisterType((*TxRaw)(nil), "cosmos.tx.v1beta1.TxRaw")
	proto.RegisterType((*SignDoc)(nil), "cosmos.tx.v1beta1.SignDoc")
	proto.RegisterType((*TxBody)(nil), "cosmos.tx.v1beta1.TxBody")
	proto.RegisterType((*AuthInfo)(nil), "cosmos.tx.v1beta1.AuthInfo")
	proto.RegisterType((*SignerInfo)(nil), "cosmos.tx.v1beta1.SignerInfo")
	proto.RegisterType((*ModeInfo)(nil), "cosmos.tx.v1beta1.ModeInfo")
	proto.RegisterType((*ModeInfo_Single)(nil), "cosmos.tx.v1beta1.ModeInfo.Single")
	proto.RegisterType((*ModeInfo_Multi)(nil), "cosmos.tx.v1beta1.ModeInfo.Multi")
	proto.RegisterType((*Fee)(nil), "cosmos.tx.v1beta1.Fee")
}

func init() { proto.RegisterFile("cosmos/tx/v1beta1/tx.proto", fileDescriptor_96d1575ffde80842) }

var fileDescriptor_96d1575ffde80842 = []byte{
	// 815 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xdd, 0x6e, 0xdc, 0x44,
	0x14, 0x8e, 0xd7, 0xbb, 0x1b, 0xfb, 0x24, 0x69, 0xe9, 0x28, 0x42, 0x9b, 0x8d, 0x9a, 0x06, 0xa3,
	0xd2, 0xbd, 0x89, 0xdd, 0xa6, 0x17, 0xfc, 0x88, 0x0b, 0xb2, 0x85, 0x2a, 0x55, 0x29, 0x48, 0x93,
	0x5c, 0xf5, 0xc6, 0x1a, 0x7b, 0x27, 0xde, 0x51, 0xd7, 0x33, 0x8b, 0x67, 0x1c, 0xec, 0x87, 0x40,
	0x42, 0x48, 0x88, 0x77, 0xe0, 0x05, 0x78, 0x05, 0x9e, 0x02, 0x78, 0x13, 0xd0, 0x8c, 0xc7, 0xce,
	0x0a, 0x56, 0xbb, 0x37, 0x5c, 0x79, 0xce, 0x99, 0xef, 0x7c, 0xf3, 0xf9, 0xfc, 0xc1, 0x38, 0x15,
	0x32, 0x17, 0x32, 0x52, 0x55, 0x74, 0xfb, 0x2c, 0xa1, 0x8a, 0x3c, 0x8b, 0x54, 0x15, 0x2e, 0x0b,
	0xa1, 0x04, 0x7a, 0xd0, 0xdc, 0x85, 0xaa, 0x0a, 0xed, 0xdd, 0xf8, 0x30, 0x13, 0x99, 0x30, 0xb7,
	0x91, 0x3e, 0x35, 0xc0, 0xf1, 0x99, 0x25, 0x49, 0x8b, 0x7a, 0xa9, 0x44, 0x94, 0x97, 0x0b, 0xc5,
	0x24, 0xcb, 0x3a, 0xc6, 0xd6, 0x61, 0xe1, 0x27, 0x16, 0x9e, 0x10, 0x49, 0x3b, 0x4c, 0x2a, 0x18,
	0xb7, 0xf7, 0x4f, 0xee, 0x34, 0x49, 0x96, 0x71, 0xc6, 0xef, 0x98, 0xac, 0x6d, 0x81, 0x47, 0x99,
	0x10, 0xd9, 0x82, 0x46, 0xc6, 0x4a, 0xca, 0x9b, 0x88, 0xf0, 0xba, 0xb9, 0x0a, 0x7e, 0x70, 0xa0,
	0x77, 0x5d, 0xa1, 0x33, 0xe8, 0x27, 0x62, 0x56, 0x8f, 0x9c, 0x53, 0x67, 0xb2, 0x77, 0x7e, 0x14,
	0xfe, 0xe7, 0x8f, 0xc2, 0xeb, 0x6a, 0x2a, 0x66, 0x35, 0x36, 0x30, 0xf4, 0x09, 0xf8, 0xa4, 0x54,
	0xf3, 0x98, 0xf1, 0x1b, 0x31, 0xea, 0x99, 0x98, 0xe3, 0x35, 0x31, 0x17, 0xa5, 0x9a, 0xbf, 0xe2,
	0x37, 0x02, 0x7b, 0xc4, 0x9e, 0xd0, 0x09, 0x80, 0xd6, 0x46, 0x54, 0x59, 0x50, 0x39, 0x72, 0x4f,
	0xdd, 0xc9, 0x3e, 0x5e, 0xf1, 0x04, 0x1c, 0x06, 0xd7, 0x15, 0x26, 0xdf, 0xa3, 0x87, 0x00, 0xfa,
	0xa9, 0x38, 0xa9, 0x15, 0x95, 0x46, 0xd7, 0x3e, 0xf6, 0xb5, 0x67, 0xaa, 0x1d, 0xe8, 0x23, 0xb8,
	0xdf, 0x29, 0xb0, 0x98, 0x9e, 0xc1, 0x1c, 0xb4, 0x4f, 0x35, 0xb8, 0x6d, 0xef, 0xfd, 0xe4, 0xc0,
	0xee, 0x15, 0xcb, 0xf8, 0x97, 0x22, 0xfd, 0xbf, 0x9e, 0x3c, 0x02, 0x2f, 0x9d, 0x13, 0xc6, 0x63,
	0x36, 0x1b, 0xb9, 0xa7, 0xce, 0xc4, 0xc7, 0xbb, 0xc6, 0x7e, 0x35, 0x43, 0x8f, 0xe1, 0x1e, 0x49,
	0x53, 0x51, 0x72, 0x15, 0xf3, 0x32, 0x4f, 0x68, 0x31, 0xea, 0x9f, 0x3a, 0x93, 0x3e, 0x3e, 0xb0,
	0xde, 0x6f, 0x8c, 0x33, 0xf8, 0xb9, 0x07, 0xc3, 0x26, 0xdf, 0xe8, 0x29, 0x78, 0x39, 0x95, 0x92,
	0x64, 0x46, 0x91, 0x3b, 0xd9, 0x3b, 0x3f, 0x0c, 0x9b, 0x6a, 0x86, 0x6d, 0x35, 0xc3, 0x0b, 0x5e,
	0xe3, 0x0e, 0x85, 0x10, 0xf4, 0x73, 0x9a, 0x37, 0x65, 0xf1, 0xb1, 0x39, 0xeb, 0x77, 0x15, 0xcb,
	0xa9, 0x28, 0x55, 0x3c, 0xa7, 0x2c, 0x9b, 0x2b, 0x23, 0xac, 0x8f, 0x0f, 0xac, 0xf7, 0xd2, 0x38,
	0xd1, 0x14, 0x1e, 0xd0, 0x4a, 0x51, 0x2e, 0x99, 0xe0, 0xb1, 0x58, 0x2a, 0x26, 0xb8, 0x1c, 0xfd,
	0xbd, 0xbb, 0xe1, 0xd9, 0xf7, 0x3a, 0xfc, 0xb7, 0x0d, 0x1c, 0xbd, 0x85, 0x13, 0x2e, 0x78, 0x9c,
	0x16, 0x4c, 0xb1, 0x94, 0x2c, 0xe2, 0x35, 0x84, 0xf7, 0x37, 0x10, 0x1e, 0x73, 0xc1, 0x5f, 0xd8,
	0xd8, 0xaf, 0xfe, 0xc5, 0x1d, 0xdc, 0x82, 0xd7, 0xb6, 0x14, 0xfa, 0x02, 0xf6, 0x75, 0x19, 0x69,
	0x61, 0xea, 0xd1, 0x26, 0xe7, 0xe1, 0x9a, 0x2e, 0xbc, 0x32, 0x30, 0xd3, 0x87, 0x7b, 0xb2, 0x3b,
	0x4b, 0x34, 0x01, 0xf7, 0x86, 0x52, 0xdb, 0xbe, 0xef, 0xaf, 0x09, 0x7c, 0x49, 0x29, 0xd6, 0x90,
	0xe0, 0x17, 0x07, 0xe0, 0x8e, 0x05, 0x3d, 0x07, 0x58, 0x96, 0xc9, 0x82, 0xa5, 0xf1, 0x3b, 0xda,
	0x8e, 0xcc, 0xfa, 0xbf, 0xf1, 0x1b, 0xdc, 0x6b, 0x6a, 0x46, 0x26, 0x17, 0x33, 0xba, 0x6d, 0x64,
	0xde, 0x88, 0x19, 0x6d, 0x46, 0x26, 0xb7, 0x27, 0x34, 0x06, 0x4f, 0xd2, 0xef, 0x4a, 0xca, 0x53,
	0x6a, 0xcb, 0xd6, 0xd9, 0xc1, 0x5f, 0x3d, 0xf0, 0xda, 0x10, 0xf4, 0x39, 0x0c, 0x25, 0xe3, 0xd9,
	0x82, 0x5a, 0x4d, 0xc1, 0x06, 0xfe, 0xf0, 0xca, 0x20, 0x2f, 0x77, 0xb0, 0x8d, 0x41, 0x9f, 0xc2,
	0xc0, 0xec, 0x1f, 0x2b, 0xee, 0x83, 0x4d, 0xc1, 0x6f, 0x34, 0xf0, 0x72, 0x07, 0x37, 0x11, 0xe3,
	0x0b, 0x18, 0x36, 0x74, 0xe8, 0x63, 0xe8, 0x6b, 0xdd, 0x46, 0xc0, 0xbd, 0xf3, 0x0f, 0x57, 0x38,
	0xda, 0x8d, 0xb4, 0x5a, 0x15, 0xcd, 0x87, 0x4d, 0xc0, 0xf8, 0x47, 0x07, 0x06, 0x86, 0x15, 0xbd,
	0x06, 0x2f, 0x61, 0x8a, 0x14, 0x05, 0x69, 0x73, 0x1b, 0xb5, 0x34, 0xcd, 0xde, 0x0c, 0xbb, 0x35,
	0xd9, 0x72, 0xbd, 0x10, 0xf9, 0x92, 0xa4, 0x6a, 0xca, 0xd4, 0x85, 0x0e, 0xc3, 0x1d, 0x01, 0xfa,
	0x0c, 0xa0, 0xcb, 0xba, 0x1e, 0x57, 0x77, 0x5b, 0xda, 0xfd, 0x36, 0xed, 0x72, 0x3a, 0x00, 0x57,
	0x96, 0x79, 0xf0, 0x9b, 0x03, 0xee, 0x4b, 0x4a, 0x51, 0x0a, 0x43, 0x92, 0xeb, 0x21, 0xb5, 0xad,
	0xd6, 0x2d, 0x49, 0xbd, 0x9e, 0x57, 0xa4, 0x30, 0x3e, 0x7d, 0xfa, 0xfb, 0x1f, 0x8f, 0x76, 0x7e,
	0xfd, 0xf3, 0xd1, 0x24, 0x63, 0x6a, 0x5e, 0x26, 0x61, 0x2a, 0xf2, 0xa8, 0x5d, 0xfd, 0xe6, 0x73,
	0x26, 0x67, 0xef, 0x22, 0x55, 0x2f, 0xa9, 0x34, 0x01, 0x12, 0x5b, 0x6a, 0x74, 0x0c, 0x7e, 0x46,
	0x64, 0xbc, 0x60, 0x39, 0x53, 0xa6, 0x10, 0x7d, 0xec, 0x65, 0x44, 0x7e, 0xad, 0x6d, 0x74, 0x08,
	0x83, 0x25, 0xa9, 0x69, 0x61, 0xb7, 0x4a, 0x63, 0xa0, 0x11, 0xec, 0x66, 0x05, 0xe1, 0xca, 0x2e,
	0x13, 0x1f, 0xb7, 0xe6, 0xf4, 0xc9, 0xdb, 0xc7, 0xdb, 0x05, 0x44, 0xaa, 0x4a, 0x86, 0xa6, 0x69,
	0x9f, 0xff, 0x13, 0x00, 0x00, 0xff, 0xff, 0x8f, 0x15, 0x6e, 0x0f, 0xe5, 0x06, 0x00, 0x00,
}
